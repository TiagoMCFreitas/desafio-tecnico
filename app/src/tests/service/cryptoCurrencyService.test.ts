import { CryptoCurrencyRepository } from "../../repository/cryptoCurrencyRepository";
import { CryptoCurrencyService } from "../../service/cryptoCurrencyService";

// Import the DTOs generated by Zod
import { FilterCryptoCurrencyDto } from "../../dto/cryptoCurrency/filterCryptoCurrency";
import { OrderCryptoCurrencyDto } from "../../dto/cryptoCurrency/orderCryptoCurrency"; // Adjust path if DTOs are in separate files
// --- Start: Helper Interfaces for Mocks ---
// Define a basic mock type for your CryptoCurrency object.
// IMPORTANT: Ensure these properties match the actual structure of your crypto currency data.
interface MockCryptoCurrency {
  id: string; // From FilterCryptoCurrencySchema (string), OrderCryptoCurrencySchema (enum, but id itself is string)
  name: string; // From FilterCryptoCurrencySchema, OrderCryptoCurrencySchema
  currentPrice: number; // From OrderCryptoCurrencySchema
  marketCap: number; // From OrderCryptoCurrencySchema
  percentPriceChange24h: number; // From OrderCryptoCurrencySchema
  percentPriceChange7D: number; // From OrderCryptoCurrencySchema
  ath: number; // From OrderCryptoCurrencySchema
  atl: number; // From OrderCryptoCurrencySchema
  // Add other properties that are part of your full CryptoCurrency object,
  // even if not directly used in these specific filters/orders, for completeness
  // ... other properties from your real CryptoCurrency entity
}

// This interface defines the expected return structure from repository methods.
// It matches what your service methods are designed to return.
interface ServiceAndRepositoryReturn {
  cryptos: MockCryptoCurrency[];
  cryptoCurrencyRequisitionInfos: {
    // Example properties, adjust based on your actual info structure.
    offset: number;
    limit: number;
    count: number;
    // Add other properties that appear in your actual requisition info
  };
}
// --- End: Helper Interfaces for Mocks ---

describe("CryptoCurrencyService", () => {
  // Declare the mocked repository.
  let mockCryptoCurrencyRepository: jest.Mocked<CryptoCurrencyRepository>;
  let cryptoCurrencyService: CryptoCurrencyService;

  beforeEach(() => {
    // Initialize the mock repository with jest.fn() for each method it's expected to have.
    mockCryptoCurrencyRepository = {
      findCryptos: jest.fn(),
      orderCryptos: jest.fn(),
    } as jest.Mocked<CryptoCurrencyRepository>;

    // Instantiate the service with the mocked repository.
    cryptoCurrencyService = new CryptoCurrencyService(
      mockCryptoCurrencyRepository
    );
  });

  describe("findCryptos", () => {
    it("should call repository with filterParams and return result", async () => {
      // Use the actual DTO type for filterParams
      const filterParams: FilterCryptoCurrencyDto = { name: "Bitcoin" }; // or { id: "some-id" }
      const mockCryptos: MockCryptoCurrency[] = [
        {
          id: "1",
          name: "Bitcoin",
          currentPrice: 50000,
          marketCap: 1e12,
          percentPriceChange24h: 2,
          percentPriceChange7D: 10,
          ath: 69000,
          atl: 100,
        },
      ];
      const expectedReturn: ServiceAndRepositoryReturn = {
        cryptos: mockCryptos,
        cryptoCurrencyRequisitionInfos: {
          offset: 0,
          limit: 200,
          count: 10000,
        },
      };

      mockCryptoCurrencyRepository.findCryptos.mockResolvedValue(
        expectedReturn
      );

      const result = await cryptoCurrencyService.findCryptos(filterParams);

      expect(mockCryptoCurrencyRepository.findCryptos).toHaveBeenCalledWith(
        filterParams
      );
      expect(result).toEqual(expectedReturn);
    });
  });

  describe("orderCryptos", () => {
    it("should transform orderParams and call repository with correct arguments and return result", async () => {
      // Use the actual DTO type for orderParams
      const orderParams: OrderCryptoCurrencyDto = {
        currentPrice: "asc",

        name: "asc",
      };
      const mockCryptos: MockCryptoCurrency[] = [
        {
          id: "2",
          name: "Ethereum",
          currentPrice: 3000,
          marketCap: 3e11,
          percentPriceChange24h: 3,
          percentPriceChange7D: 15,
          ath: 4800,
          atl: 50,
        },
      ];
      const expectedReturn: ServiceAndRepositoryReturn = {
        cryptos: mockCryptos,
        cryptoCurrencyRequisitionInfos: {
          offset: 0,
          limit: 200,
          count: 10000,
        },
      };

      mockCryptoCurrencyRepository.orderCryptos.mockResolvedValue(
        expectedReturn
      );

      const result = await cryptoCurrencyService.orderCryptos(orderParams);

      // Define the expected transformed arrays based on the service's logic
      // Properties of OrderCryptoCurrencyDto can be 'asc' or 'desc' (literals)
      const expectedOrderByArray = [{ currentPrice: "asc" }, { name: "asc" }];
      // 'id' is excluded in the service's logic for removingNullValues
      const expectedRemovingNullValues = [
        { currentPrice: { not: null } },
        { name: { not: null } },
      ];

      expect(mockCryptoCurrencyRepository.orderCryptos).toHaveBeenCalledWith(
        orderParams,
        expectedRemovingNullValues,
        expectedOrderByArray
      );
      expect(result).toEqual(expectedReturn);
    });

    it("should not include 'id' in removingNullValues but include it in orderByArray", async () => {
      const orderParams: OrderCryptoCurrencyDto = {
        id: "asc",
        currentPrice: "desc",
      };
      const mockCryptos: MockCryptoCurrency[] = [];
      const expectedReturn: ServiceAndRepositoryReturn = {
        cryptos: mockCryptos,
        cryptoCurrencyRequisitionInfos: {
          offset: 0,
          limit: 200,
          count: 10000,
        },
      };

      mockCryptoCurrencyRepository.orderCryptos.mockResolvedValue(
        expectedReturn
      );

      const result = await cryptoCurrencyService.orderCryptos(orderParams);

      const expectedRemovingNullValues = [{ currentPrice: { not: null } }];
      const expectedOrderByArray = [{ id: "asc" }, { currentPrice: "desc" }];

      expect(mockCryptoCurrencyRepository.orderCryptos).toHaveBeenCalledWith(
        orderParams,
        expectedRemovingNullValues,
        expectedOrderByArray
      );
      expect(result).toEqual(expectedReturn);
    });

    it("should handle empty orderParams by passing empty arrays to repository", async () => {
      const orderParams: OrderCryptoCurrencyDto = {}; // Empty object is valid
      const mockCryptos: MockCryptoCurrency[] = [];
      const expectedReturn: ServiceAndRepositoryReturn = {
        cryptos: mockCryptos,
        cryptoCurrencyRequisitionInfos: {
          offset: 0,
          limit: 200,
          count: 10000,
        },
      };

      mockCryptoCurrencyRepository.orderCryptos.mockResolvedValue(
        expectedReturn
      );

      const result = await cryptoCurrencyService.orderCryptos(orderParams);

      expect(mockCryptoCurrencyRepository.orderCryptos).toHaveBeenCalledWith(
        {}, // original orderParams
        [], // removingNullValues
        [] // orderByArray
      );
      expect(result).toEqual(expectedReturn);
    });
  });
});
